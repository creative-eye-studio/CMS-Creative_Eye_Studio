<?php

namespace Copiaincolla\MetaTagsBundle\Repository;

use Doctrine\ORM\EntityRepository;
use Copiaincolla\MetaTagsBundle\Entity\MetatagDefaults;

/**
 * MetatagDefaultsRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class MetatagDefaultsRepository extends EntityRepository
{
    /**
     * Get (if exesting) in order of importance, MetatagDefaults entities whose path regex is matching $path
     */
    public function getMatching($path)
    {
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('e')
            ->from('CopiaincollaMetaTagsBundle:MetatagDefaults', 'e')
            ->orderBy('e.importance', 'DESC')
        ;

        $result = $qb->getQuery()->getResult();

        $output = array();

        foreach ($result as $entity) {
            $regex = preg_replace('/#/', '\#', $entity->getPathRegex());
            $regex = "#$regex#";

            if (preg_match($regex, $path)) {
                $output[] = $entity;
            }
        }

        return $output;
    }

    /**
     * Edit the importance of a regex rule by moving it up or down
     *
     * @var metatagDefaults
     * @var direction up|down
     */
    public function editImportance(MetatagDefaults $metatagDefaults, $direction = 'up')
    {
        $em = $this->getEntityManager();

        $qb = $em->createQueryBuilder()
            ->select('e')
            ->from('CopiaincollaMetaTagsBundle:MetatagDefaults', 'e')
            ->orderBy('e.importance', 'ASC')
        ;

        $result = $qb->getQuery()->getResult();

        foreach ($result as $k => $entity) {

            if ($entity->getId() == $metatagDefaults->getId()) {
                if ('up' == $direction) {

                    // it is already the maximum
                    if (!array_key_exists($k+1, $result)) {
                        break;
                    }

                    $tmp = $result[$k+1];
                    $result[$k+1] = $result[$k];
                    $result[$k] = $tmp;
                } elseif ('down' == $direction) {

                    // it is already the minimum
                    if (!array_key_exists($k-1, $result)) {
                        break;
                    }

                    $tmp = $result[$k];
                    $result[$k] = $result[$k-1];
                    $result[$k-1] = $tmp;
                }
            }
        }

        foreach ($result as $k => $entity) {
            $entity->setImportance($k);
            $em->persist($entity);
        }

        $em->flush();
    }
}